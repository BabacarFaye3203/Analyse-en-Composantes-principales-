M6 = c(1.10, 22.13, 16.77, 6.23, 7.71, 32.11, 4.75, 0),
M7 = c(1.19, 7.31, 9.03, 37.58, 34.41, 66.57, 9.56, 0.30),
M8 = c(4.24, 6.15, 8.92, 17.47, 22.34, 44.60, 12.93, 1.20),
M9 = c(5.23, 1.03, 2.90, 8.13, 8.42, 23.49, 2.31, 0.40),
M10 = c(3.64, 9.23, 12.99, 8.88, 29.45, 57.43, 11.51, 1.00)
)
# Afficher les donn√©es
print("Donn√©es Cancer :")
print(cancer_data)
# Pr√©paration des donn√©es pour ACP (sans la colonne Type)
x_cancer <- cancer_data[, -1]
rownames(x_cancer) <- cancer_data$Type
# -------------------------------
# 2.1 Exploration des donn√©es
# -------------------------------
# Afficher la matrice X
print("Matrice X (Cancer) :")
print(x_cancer)
# R√©sum√© statistique
print("Summary de X :")
print(summary(x_cancer))
# Boxplot
boxplot(x_cancer, main = "Boxplot des marqueurs (Cancer)", las = 2, col = "lightblue")
# R√©sum√© de la transpos√©e
print("Summary de t(X) :")
print(summary(t(x_cancer)))
# -------------------------------
# 2.2 Matrice de corr√©lation
# -------------------------------
matCors <- cor(x_cancer)
print("Matrice de corr√©lation :")
print(matCors)
# Repr√©sentation symbolique
print("Repr√©sentation symbolique des corr√©lations :")
print(symnum(matCors, abbr.colnames = FALSE))
# Visualisation avec corrplot
corrplot(matCors,
type = "upper",
order = "hclust",
tl.col = "black",
tl.srt = 45,
main = "Matrice de corr√©lation (Cancer)")
# -------------------------------
# 2.3 Normalisation des donn√©es
# -------------------------------
Xsc <- scale(x_cancer, scale = TRUE, center = TRUE)
print("Donn√©es centr√©es-r√©duites :")
print(Xsc)
boxplot(Xsc, main = "Boxplot des donn√©es centr√©es-r√©duites", las = 2, col = "lightgreen")
# -------------------------------
# 2.4 ACP manuelle (calculs matriciels)
# -------------------------------
# Matrice de variance-covariance
Sigma <- t(Xsc) %*% Xsc / (nrow(Xsc) - 1)
print("Matrice de variance-covariance :")
print(Sigma)
# D√©composition en valeurs propres
ACP <- eigen(Sigma)
print("Valeurs propres :")
print(ACP$values)
# Graphique des valeurs propres (√©boulis)
plot(ACP$values,
type = "b",
main = "√âboulis des valeurs propres",
xlab = "Composante",
ylab = "Valeur propre",
col = "blue", pch = 19)
# Inertie cumul√©e
inertie <- cumsum(ACP$values) / sum(ACP$values)
print("Inertie cumul√©e :")
print(inertie)
pourc_inertie <- inertie * 100
print("Pourcentage d'inertie cumul√©e :")
print(pourc_inertie)
# Graphique du pourcentage d'inertie
plot(pourc_inertie,
type = "b",
main = "Pourcentage d'inertie expliqu√©e",
xlab = "Nombre de composantes",
ylab = "Inertie cumul√©e (%)",
col = "red", pch = 19)
abline(h = 80, col = "gray", lty = 2)  # Seuil √† 80%
# -------------------------------
# 2.5 Composantes principales
# -------------------------------
# Matrice des composantes principales
CP <- Xsc %*% ACP$vectors
colnames(CP) <- paste0("PC", 1:ncol(CP))
print("Composantes principales :")
print(CP)
# Qualit√© de repr√©sentation (cos¬≤)
cos2_ind <- diag(CP[, 1:2] %*% t(CP[, 1:2])) / diag(Xsc %*% t(Xsc))
print("Cos¬≤ des individus (qualit√© de repr√©sentation) :")
print(cos2_ind)
# -------------------------------
# 2.6 Repr√©sentation graphique
# -------------------------------
# Individus dans le plan principal
plot(CP[, 1:2],
pch = 19,
cex = cos2_ind * 2 + 0.5,  # Taille proportionnelle au cos¬≤
main = "Repr√©sentation des individus (Cancer)",
xlab = paste0("PC1 (", round(ACP$values[1]/sum(ACP$values)*100, 1), "%)"),
ylab = paste0("PC2 (", round(ACP$values[2]/sum(ACP$values)*100, 1), "%)"),
col = "blue")
text(CP[, 1:2], labels = rownames(x_cancer), pos = 3, cex = 0.8)
# Cercle des corr√©lations
Rho <- diag(1/sqrt(diag(Sigma))) %*% ACP$vectors %*% diag(sqrt(ACP$values))
rownames(Rho) <- colnames(x_cancer)
colnames(Rho) <- paste0("PC", 1:ncol(Rho))
print("Corr√©lations variables-composantes :")
print(Rho)
# V√©rification dans le cercle unit√©
plot(Rho[, 1:2],
type = "n",
xlim = c(-1.1, 1.1),
ylim = c(-1.1, 1.1),
main = "Cercle des corr√©lations",
xlab = "PC1",
ylab = "PC2")
abline(h = 0, v = 0, col = "gray")
symbols(0, 0, circles = 1, inches = FALSE, add = TRUE, lty = 2)
arrows(0, 0, Rho[, 1], Rho[, 2], length = 0.1, col = "red")
text(Rho[, 1:2], labels = rownames(Rho), pos = 3, cex = 0.8, col = "blue")
# Biplot
biplot(CP[, 1:2], Rho[, 1:2],
main = "Biplot - Individus et variables",
xlab = paste0("PC1 (", round(ACP$values[1]/sum(ACP$values)*100, 1), "%)"),
ylab = paste0("PC2 (", round(ACP$values[2]/sum(ACP$values)*100, 1), "%)"),
cex = 0.8)
# -------------------------------
# 2.7 ACP avec FactoMineR (version simplifi√©e)
# -------------------------------
res.acp <- PCA(x_cancer, graph = FALSE)
data <- read.table("cancers.txt", sep="\t", header=T)
colnames(data)
rownames(data) = data[,1] # On donne √† chaque ligne le nom de son cancer
x <- data[1:7, -1]        # On exclue la colonne 1 qui contenait les noms des cancers
x
matCors <- cor(x)
matCors
symnum(matCors, abbr.colnames=FALSE)
library(corrplot)
corrplot(matCors, type="upper", order="hclust", tl.col="black", tl.srt=45)
data <- read.table("cancers.txt", sep="\t", header=T)
colnames(data)
rownames(data) = data[,1] # On donne √† chaque ligne le nom de son cancer
x <- data[1:7, -1]        # On exclue la colonne 1 qui contenait les noms des cancers
x
matCors <- cor(x)
matCors
symnum(matCors, abbr.colnames=FALSE)
library(corrplot)
corrplot(matCors, type="upper", order="hclust", tl.col="black", tl.srt=45)
> plot(ACP$values/sum(ACP$values), type="b")
str(x)        # v√©rifier le type et les dimensions
head(x)       # afficher les premi√®res lignes
sapply(x, class)  # v√©rifier que toutes les colonnes sont num√©riques
head(data)
dim(data)
colnames(data)
data <- read.table("cancers.txt", header=TRUE, sep="", stringsAsFactors = FALSE)
data <- read.table("cancers.txt", header = FALSE, stringsAsFactors = FALSE)
data <- read.table("cancers.txt", header = FALSE, stringsAsFactors = FALSE)
# -------------------------------
# Lecture et pr√©paration des donn√©es
# -------------------------------
# Lire le fichier sans header (header=FALSE) et ignorer les facteurs
data <- read.table("cancers.txt", header = FALSE, stringsAsFactors = FALSE)
# -------------------------------
# Lecture et pr√©paration des donn√©es
# -------------------------------
data <- read.table("cancers.txt", header = FALSE, stringsAsFactors = FALSE)
# 1Ô∏è‚É£ Lire le fichier brut
raw <- readLines("cancers.txt")
# 2Ô∏è‚É£ Supprimer la premi√®re ligne si c'est l'en-t√™te
header <- raw[1]
raw <- raw[-1]
# 3Ô∏è‚É£ Fusionner les lignes cass√©es
# On consid√®re que chaque cancer commence par "Cancer"
data_lines <- c()
tmp <- ""
for (line in raw) {
line <- trimws(line)  # enlever espaces au d√©but et fin
if (grepl("^Cancer", line)) {
if (tmp != "") data_lines <- c(data_lines, tmp)
tmp <- line
} else {
tmp <- paste(tmp, line)  # concat√©ner les lignes suivantes
}
}
data_lines <- c(data_lines, tmp)  # ajouter le dernier cancer
# 4Ô∏è‚É£ Transformer en data.frame
library(stringr)
data_split <- str_split(data_lines, "\\s+", simplify = TRUE)
data_df <- as.data.frame(data_split, stringsAsFactors = FALSE)
# 5Ô∏è‚É£ Ajouter les noms de colonnes
colnames(data_df) <- c("Type","M1","M2","M3","M4","M5","M6","M7","M8","M9","M10")
# 6Ô∏è‚É£ Convertir les colonnes num√©riques
for (i in 2:11) {
data_df[,i] <- as.numeric(data_df[,i])
}
# 7Ô∏è‚É£ Mettre les noms des lignes
rownames(data_df) <- data_df$Type
x <- data_df[, -1]  # seules les colonnes num√©riques
# 8Ô∏è‚É£ V√©rification
str(x)
head(x)
# Ajouter les noms de colonnes manuellement (Type + M1 √† M10)
colnames(data) <- c("Type","M1","M2","M3","M4","M5","M6","M7","M8","M9","M10")
# 1Ô∏è‚É£ Lire le fichier brut
raw <- readLines("cancers.txt")
# 2Ô∏è‚É£ Supprimer la premi√®re ligne si c'est l'en-t√™te
header <- raw[1]
raw <- raw[-1]
# 3Ô∏è‚É£ Fusionner les lignes cass√©es
# On consid√®re que chaque cancer commence par "Cancer"
data_lines <- c()
tmp <- ""
for (line in raw) {
line <- trimws(line)  # enlever espaces au d√©but et fin
if (grepl("^Cancer", line)) {
if (tmp != "") data_lines <- c(data_lines, tmp)
tmp <- line
} else {
tmp <- paste(tmp, line)  # concat√©ner les lignes suivantes
}
}
data_lines <- c(data_lines, tmp)  # ajouter le dernier cancer
# 4Ô∏è‚É£ Transformer en data.frame
library(stringr)
data_split <- str_split(data_lines, "\\s+", simplify = TRUE)
data_df <- as.data.frame(data_split, stringsAsFactors = FALSE)
# 5Ô∏è‚É£ Ajouter les noms de colonnes
colnames(data_df) <- c("Type","M1","M2","M3","M4","M5","M6","M7","M8","M9","M10")
# 6Ô∏è‚É£ Convertir les colonnes num√©riques
for (i in 2:11) {
data_df[,i] <- as.numeric(data_df[,i])
}
# 7Ô∏è‚É£ Mettre les noms des lignes
rownames(data_df) <- data_df$Type
x <- data_df[, -1]  # seules les colonnes num√©riques
# 8Ô∏è‚É£ V√©rification
str(x)
head(x)
# Ajouter les noms de colonnes manuellement (Type + M1 √† M10)
colnames(data) <- c("Type","M1","M2","M3","M4","M5","M6","M7","M8","M9","M10")
# -------------------------------
# 1Ô∏è‚É£ Lecture et pr√©paration des donn√©es
# -------------------------------
# Lecture du fichier
data <- read.table("cancers.txt", sep="\t", header=TRUE, stringsAsFactors = FALSE)
# V√©rifier les noms de colonnes
colnames(data)
# Donner les noms des lignes (nom du cancer)
rownames(data) <- data[,1]
# Extraire la matrice num√©rique (7 lignes x 10 colonnes)
x <- data[1:7, -1]
x <- as.data.frame(lapply(x, as.numeric))  # convertir en num√©rique
# V√©rification
str(x)
x
# -------------------------------
# 2Ô∏è‚É£ Exploration du jeu de donn√©es
# -------------------------------
# Afficher la matrice
print(x)
# R√©sum√© statistique des variables
summary(x)
# Bo√Ætes √† moustaches
boxplot(x, main="Boxplots des marqueurs de cancers")
# -------------------------------
# 1Ô∏è‚É£ Lecture et pr√©paration des donn√©es
# -------------------------------
# Lecture du fichier
data <- read.table("cancers.txt", sep="\t", header=TRUE, stringsAsFactors = FALSE)
# V√©rifier les noms de colonnes
colnames(data)
# Donner les noms des lignes (nom du cancer)
rownames(data) <- data[,1]
# Extraire la matrice num√©rique (7 lignes x 10 colonnes)
x <- data[1:7, -1]
x <- as.data.frame(lapply(x, as.numeric))
# V√©rification
str(x)
x
# -------------------------------
# 2Ô∏è‚É£ Exploration du jeu de donn√©es
# -------------------------------
# Afficher la matrice
print(x)
# R√©sum√© statistique des variables
summary(x)
# Bo√Ætes √† moustaches
boxplot(x, main="Boxplots des marqueurs de cancers")
# -------------------------------
# 1Ô∏è‚É£ Lecture et pr√©paration des donn√©es
# -------------------------------
# Lire le fichier
data <- read.table("cancers.txt", sep="\t", header=TRUE, stringsAsFactors=FALSE)
# V√©rifier les noms de colonnes
colnames(data)
# Donner les noms des lignes (nom du cancer)
rownames(data) <- data[,1]
# Extraire la matrice num√©rique
x <- data[1:7, -1]
# üîπ S'assurer que toutes les colonnes sont num√©riques
x <- as.data.frame(lapply(x, function(col) as.numeric(as.character(col))))
# V√©rification
str(x)
head(x)
# -------------------------------
# 2Ô∏è‚É£ Exploration
# -------------------------------
# Afficher la matrice
print(x)
# R√©sum√© statistique
summary(x)
# Bo√Ætes √† moustaches
boxplot(x, main="Boxplots des marqueurs de cancers")
data <- read.table("cancers_clean.txt", sep="", header=TRUE, stringsAsFactors=FALSE)
data <- read.table("cancers.txt", sep="", header=TRUE, stringsAsFactors=FALSE)
data <- read.table("cancers.txt", sep="", header=TRUE, stringsAsFactors=FALSE)
rownames(data) <- data$Type
x <- data[, -1]
x <- as.data.frame(lapply(x, as.numeric))
str(x)
boxplot(x, main="Boxplots des marqueurs de cancers")
# R√©sum√© des individus
summary(t(x))
# -------------------------------
# 3Ô∏è‚É£ Matrice de corr√©lation
# -------------------------------
matCors <- cor(x)
matCors
symnum(matCors, abbr.colnames=FALSE)
library(corrplot)
corrplot(matCors, type="upper", order="hclust", tl.col="black", tl.srt=45)
# -------------------------------
# 4Ô∏è‚É£ ACP
# -------------------------------
Xsc <- scale(x, scale=FALSE)
boxplot(Xsc, main="Boxplot des marqueurs centr√©s")
Sigma <- t(Xsc) %*% Xsc / nrow(Xsc)
ACP <- eigen(Sigma)
# Valeurs propres et scree plot
ACP$values
plot(ACP$values, type="b", xlab="Composante", ylab="Valeur propre", main="Scree plot")
# Inertie cumul√©e
inertie <- cumsum(ACP$values)/sum(ACP$values)
pourcinertie <- inertie*100
pourcinertie
plot(ACP$values/sum(ACP$values), type="b", xlab="Composante", ylab="Proportion variance expliqu√©e")
# -------------------------------
# 5Ô∏è‚É£ Composantes principales
# -------------------------------
CP <- as.matrix(Xsc) %*% ACP$vectors
rownames(CP) <- rownames(x)
colnames(CP) <- paste0("PC", 1:ncol(CP))
CP
# -------------------------------
# 6Ô∏è‚É£ Qualit√© de repr√©sentation (cos¬≤)
# -------------------------------
cos2 <- rowSums(CP^2)/sum(ACP$values)
cos2
# -------------------------------
# 7Ô∏è‚É£ Contributions des individus
# -------------------------------
n <- nrow(Xsc)
contrib <- CP^2 / (n * matrix(ACP$values, nrow=n, ncol=ncol(CP), byrow=TRUE))
contrib
# -------------------------------
# 8Ô∏è‚É£ Repr√©sentation graphique
# -------------------------------
plot(CP[,1:2], pch=2, cex=cos2*5, xlab="PC1", ylab="PC2", main="Projection des cancers sur PC1-PC2")
text(CP[,1:2], labels=rownames(CP), pos=3)
# -------------------------------
# 9Ô∏è‚É£ Corr√©lation variables initiales / composantes
# -------------------------------
Rho <- diag(1/sqrt(diag(Sigma))) %*% ACP$vectors %*% diag(sqrt(ACP$values))
rownames(Rho) <- colnames(x)
colnames(Rho) <- paste0("PC", 1:ncol(Rho))
Rho
data <- read.table("cancers.txt", sep="", header=TRUE, stringsAsFactors=FALSE)
rownames(data) <- data$Type
x <- data[, -1]
x <- as.data.frame(lapply(x, as.numeric))
str(x)
boxplot(x, main="Boxplots des marqueurs de cancers")
# R√©sum√© des individus
summary(t(x))
matCors <- cor(x)
matCors
symnum(matCors, abbr.colnames=FALSE)
library(corrplot)
corrplot(matCors, type="upper", order="hclust", tl.col="black", tl.srt=45)
# Lecture des donn√©es depuis le fichier et pr√©paration
data <- read.table("cancers.txt", sep="", header=TRUE, stringsAsFactors=FALSE)
rownames(data) <- data$Type                     # Mettre le nom du cancer comme ligne
x <- data[, -1]                                 # Extraire seulement les valeurs num√©riques
x <- as.data.frame(lapply(x, as.numeric))       # S'assurer que toutes les colonnes sont num√©riques
# V√©rification de la structure et visualisation des donn√©es
str(x)                                          # V√©rifie les dimensions et le type des colonnes
boxplot(x, main="Boxplots des marqueurs de cancers")  # Bo√Ætes √† moustaches pour d√©tecter les distributions
summary(t(x))                                   # R√©sum√© statistique par individu (ligne)
# Matrice de corr√©lation entre les marqueurs
matCors <- cor(x)                               # Calcul des corr√©lations
matCors
symnum(matCors, abbr.colnames=FALSE)           # Affichage simplifi√© des corr√©lations
library(corrplot)
corrplot(matCors, type="upper", order="hclust", tl.col="black", tl.srt=45)  # Graphique hi√©rarchis√©
# Analyse en Composantes Principales (ACP)
Xsc <- scale(x, scale=FALSE)                   # Centrer les donn√©es sans standardisation
boxplot(Xsc, main="Boxplot des marqueurs centr√©s")  # V√©rifier les donn√©es centr√©es
Sigma <- t(Xsc) %*% Xsc / nrow(Xsc)           # Matrice de covariance
ACP <- eigen(Sigma)                            # Valeurs et vecteurs propres
ACP$values                                    # Valeurs propres (variance expliqu√©e)
plot(ACP$values, type="b", xlab="Composante", ylab="Valeur propre", main="Scree plot")  # Scree plot
inertie <- cumsum(ACP$values)/sum(ACP$values) # Inertie cumul√©e
pourcinertie <- inertie*100                    # Pourcentage de variance expliqu√©e
pourcinertie
plot(ACP$values/sum(ACP$values), type="b", xlab="Composante", ylab="Proportion variance expliqu√©e")
# Calcul des composantes principales pour chaque individu
CP <- as.matrix(Xsc) %*% ACP$vectors
rownames(CP) <- rownames(x)
colnames(CP) <- paste0("PC", 1:ncol(CP))
CP
# Qualit√© de repr√©sentation des individus (cos¬≤)
cos2 <- rowSums(CP^2)/sum(ACP$values)
cos2
# Contribution des individus √† la construction des axes
n <- nrow(Xsc)
contrib <- CP^2 / (n * matrix(ACP$values, nrow=n, ncol=ncol(CP), byrow=TRUE))
contrib
# Repr√©sentation graphique des individus dans le plan principal
plot(CP[,1:2], pch=2, cex=cos2*5, xlab="PC1", ylab="PC2", main="Projection des cancers sur PC1-PC2")
text(CP[,1:2], labels=rownames(CP), pos=3)  # Ajouter les noms des individus
# Corr√©lation des variables initiales avec les composantes principales
Rho <- diag(1/sqrt(diag(Sigma))) %*% ACP$vectors %*% diag(sqrt(ACP$values))
rownames(Rho) <- colnames(x)
colnames(Rho) <- paste0("PC", 1:ncol(Rho))
Rho
data <- read.table("cancers.txt", sep="", header=TRUE, stringsAsFactors=FALSE)
rownames(data) <- data$Type
x <- data[, -1]
x <- as.data.frame(lapply(x, as.numeric))
str(x)
boxplot(x, main="Boxplots des marqueurs de cancers")
summary(t(x))
matCors <- cor(x)
matCors
symnum(matCors, abbr.colnames=FALSE)
library(corrplot)
corrplot(matCors, type="upper", order="hclust", tl.col="black", tl.srt=45)
Xsc <- scale(x, scale=FALSE)
boxplot(Xsc, main="Boxplot des marqueurs centr√©s")
Sigma <- t(Xsc) %*% Xsc / nrow(Xsc)
ACP <- eigen(Sigma)
ACP$values
plot(ACP$values, type="b", xlab="Composante", ylab="Valeur propre", main="Scree plot")
inertie <- cumsum(ACP$values)/sum(ACP$values)
pourcinertie <- inertie*100
pourcinertie
plot(ACP$values/sum(ACP$values), type="b", xlab="Composante", ylab="Proportion variance expliqu√©e")
CP <- as.matrix(Xsc) %*% ACP$vectors
rownames(CP) <- rownames(x)
colnames(CP) <- paste0("PC", 1:ncol(CP))
CP
cos2 <- rowSums(CP^2)/sum(ACP$values)
cos2
n <- nrow(Xsc)
contrib <- CP^2 / (n * matrix(ACP$values, nrow=n, ncol=ncol(CP), byrow=TRUE))
contrib
plot(CP[,1:2], pch=2, cex=cos2*5, xlab="PC1", ylab="PC2", main="Projection des cancers sur PC1-PC2")
text(CP[,1:2], labels=rownames(CP), pos=3)
Rho <- diag(1/sqrt(diag(Sigma))) %*% ACP$vectors %*% diag(sqrt(ACP$values))
rownames(Rho) <- colnames(x)
colnames(Rho) <- paste0("PC", 1:ncol(Rho))
Rho
str(x)
boxplot(x, main="Boxplots des marqueurs de cancers")
summary(t(x))
matCors <- cor(x)
matCors
symnum(matCors, abbr.colnames=FALSE)
library(corrplot)
corrplot(matCors, type="upper", order="hclust", tl.col="black", tl.srt=45)
Xsc <- scale(x, scale=FALSE)
boxplot(Xsc, main="Boxplot des marqueurs centr√©s")
Sigma <- t(Xsc) %*% Xsc / nrow(Xsc)
ACP <- eigen(Sigma)
ACP$values
plot(ACP$values, type="b", xlab="Composante", ylab="Valeur propre", main="Scree plot")
inertie <- cumsum(ACP$values)/sum(ACP$values)
pourcinertie <- inertie*100
pourcinertie
plot(ACP$values/sum(ACP$values), type="b", xlab="Composante", ylab="Proportion variance expliqu√©e")
CP <- as.matrix(Xsc) %*% ACP$vectors
rownames(CP) <- rownames(x)
colnames(CP) <- paste0("PC", 1:ncol(CP))
CP
cos2 <- rowSums(CP^2)/sum(ACP$values)
cos2
n <- nrow(Xsc)
contrib <- CP^2 / (n * matrix(ACP$values, nrow=n, ncol=ncol(CP), byrow=TRUE))
contrib
plot(CP[,1:2], pch=2, cex=cos2*5, xlab="PC1", ylab="PC2", main="Projection des cancers sur PC1-PC2")
text(CP[,1:2], labels=rownames(CP), pos=3)
Rho <- diag(1/sqrt(diag(Sigma))) %*% ACP$vectors %*% diag(sqrt(ACP$values))
rownames(Rho) <- colnames(x)
colnames(Rho) <- paste0("PC", 1:ncol(Rho))
Rho
